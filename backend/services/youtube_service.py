"""
YouTube integration service for video uploads
"""

import os
import json
import pickle
from typing import Optional, Dict, Any
from pathlib import Path
from datetime import datetime, timedelta

import google_auth_httplib2
import google_auth_oauthlib
import googleapiclient.discovery
import googleapiclient.errors
import googleapiclient.http
from google.oauth2.credentials import Credentials
from google.auth.transport.requests import Request as GoogleAuthRequest

from backend.models.database import Database
from backend.utils.config import Config

class YouTubeService:
    """Service for YouTube video uploads with OAuth2 authentication"""
    
    # YouTube API scopes
    SCOPES = ["https://www.googleapis.com/auth/youtube.upload"]
    
    def __init__(self, database: Database):
        self.db = database
        self.credentials_file = "client_sectets.json"  # Note: keeping original filename
        self.token_file = "data/token.json"
        self.service = None
        self._ensure_token_directory()
    
    def _ensure_token_directory(self):
        """Ensure token directory exists"""
        token_path = Path(self.token_file)
        token_path.parent.mkdir(parents=True, exist_ok=True)
    
    def _authenticate_youtube(self):
        """Authenticate with YouTube API using the working method"""
        # Set insecure transport for local development
        os.environ["OAUTHLIB_INSECURE_TRANSPORT"] = "1"

        creds: Optional[Credentials] = None
        # Try loading existing token and refresh if needed
        if os.path.exists(self.token_file):
            try:
                creds = Credentials.from_authorized_user_file(self.token_file, scopes=self.SCOPES)
            except Exception:
                creds = None

        if creds and creds.expired and creds.refresh_token:
            try:
                creds.refresh(GoogleAuthRequest())
                # Persist refreshed token
                Path(self.token_file).parent.mkdir(parents=True, exist_ok=True)
                with open(self.token_file, "w", encoding="utf-8") as token_out:
                    token_out.write(creds.to_json())
            except Exception:
                creds = None

        if not creds or not creds.valid:
            # Fresh auth flow
            if not os.path.exists(self.credentials_file):
                raise FileNotFoundError(f"Credentials file {self.credentials_file} not found")
            flow = google_auth_oauthlib.flow.InstalledAppFlow.from_client_secrets_file(
                self.credentials_file, self.SCOPES
            )
            creds = flow.run_local_server(port=0)
            # Save new token
            Path(self.token_file).parent.mkdir(parents=True, exist_ok=True)
            with open(self.token_file, "w", encoding="utf-8") as token_out:
                token_out.write(creds.to_json())

        youtube = googleapiclient.discovery.build("youtube", "v3", credentials=creds)
        return youtube
    
    def _generate_video_title(self, video_info: Dict[str, Any], caption: str) -> str:
        """Generate YouTube video title from caption"""
        # Extract hook from caption (first line)
        lines = caption.strip().split('\n')
        hook = lines[0] if lines else video_info.get('title', 'Video')
        
        # Clean up the hook for title
        title = hook.replace('?', '').replace('!', '').strip()
        
        # Add relevant keywords
        topic = video_info.get('topic', '')
        if 'ai' in topic.lower() or 'artificial intelligence' in topic.lower():
            title += " | AI & Machine Learning"
        elif 'tutorial' in topic.lower():
            title += " | Tutorial"
        elif 'pilot' in topic.lower():
            title += " | Aviation & AI"
        
        # Limit title length (YouTube max is 100 characters)
        if len(title) > 100:
            title = title[:97] + "..."
        
        return title
    
    def _generate_video_description(self, caption: str, video_info: Dict[str, Any]) -> str:
        """Generate YouTube video description"""
        description = f"""🎬 {caption}

📝 About this video:
This video covers {video_info.get('topic', 'the topic')} and provides valuable insights you can apply immediately.

🔖 Timestamps:
00:00 - Introduction
00:30 - Main Content
02:00 - Key Takeaways
02:30 - Conclusion

📚 Related Topics:
• {video_info.get('topic', 'Technology')}
• AI & Machine Learning
• Innovation & Technology

👍 If you found this helpful, please:
• Like this video
• Subscribe for more content
• Share with others who might benefit

#AI #MachineLearning #Technology #Innovation #Tutorial #Learning #TechForGood #FutureOfWork #ArtificialIntelligence #DeepLearning #ComputerVision #DataScience #WatchTillEnd

---
Generated by Video Caption Generator
"""
        return description
    
    def _generate_video_tags(self, video_info: Dict[str, Any], caption: str) -> list:
        """Generate YouTube video tags"""
        base_tags = [
            "AI", "Machine Learning", "Technology", "Innovation", 
            "Tutorial", "Learning", "TechForGood", "FutureOfWork",
            "Artificial Intelligence", "Deep Learning", "Computer Vision",
            "Data Science", "WatchTillEnd"
        ]
        
        # Add topic-specific tags
        topic = video_info.get('topic', '').lower()
        if 'ai' in topic or 'artificial intelligence' in topic:
            base_tags.extend(["AI Tutorial", "Machine Learning Basics", "AI Explained"])
        elif 'pilot' in topic:
            base_tags.extend(["Aviation", "Pilot Training", "Flight Safety", "AI in Aviation"])
        elif 'tutorial' in topic:
            base_tags.extend(["How To", "Step by Step", "Guide", "Tutorial"])
        
        # Extract hashtags from caption
        lines = caption.split('\n')
        for line in lines:
            if line.startswith('#'):
                tags = [tag.strip('#') for tag in line.split()]
                base_tags.extend(tags)
        
        # Remove duplicates and limit to 15 tags (YouTube limit)
        unique_tags = list(dict.fromkeys(base_tags))[:15]
        return unique_tags
    
    def upload_video(self, video_path: str, video_info: Dict[str, Any], caption: str) -> Dict[str, Any]:
        """Upload video to YouTube with generated title and description"""
        try:
            # Get authenticated service
            youtube = self._authenticate_youtube()
            
            # Generate metadata
            title = self._generate_video_title(video_info, caption)
            description = self._generate_video_description(caption, video_info)
            tags = self._generate_video_tags(video_info, caption)
            
            # Video metadata - using the working format
            request_body = {
                "snippet": {
                    "categoryId": "28",  # Science & Technology category
                    "title": title,
                    "description": description,
                    "tags": tags
                },
                "status": {
                    "privacyStatus": "private"  # Start as private, user can change later
                }
            }
            
            # Create media upload - using the working format
            media_file = googleapiclient.http.MediaFileUpload(
                video_path, 
                chunksize=-1, 
                resumable=True
            )
            
            # Upload video - using the working format
            request = youtube.videos().insert(
                part="snippet,status",
                body=request_body,
                media_body=media_file
            )
            
            # Execute upload
            response = None
            while response is None:
                status, response = request.next_chunk()
                if status:
                    print(f"Upload {int(status.progress() * 100)}%")
            
            if 'id' in response:
                video_id = response['id']
                video_url = f"https://www.youtube.com/watch?v={video_id}"
                
                # Save upload info to database
                self._save_upload_info(video_info, video_id, video_url, title)
                
                return {
                    'success': True,
                    'video_id': video_id,
                    'video_url': video_url,
                    'title': title,
                    'message': f'Video uploaded successfully! URL: {video_url}'
                }
            else:
                return {
                    'success': False,
                    'error': 'Upload failed - no video ID returned'
                }
                
        except googleapiclient.errors.HttpError as e:
            error_details = e.error_details[0] if e.error_details else {}
            return {
                'success': False,
                'error': f'YouTube API error: {error_details.get("message", str(e))}'
            }
        except Exception as e:
            return {
                'success': False,
                'error': f'Upload failed: {str(e)}'
            }
    
    def _save_upload_info(self, video_info: Dict[str, Any], video_id: str, video_url: str, title: str):
        """Save upload information to database"""
        upload_data = {
            'video_id': video_id,
            'video_url': video_url,
            'title': title,
            'uploaded_at': datetime.now().isoformat(),
            'original_video': video_info.get('title', ''),
            'topic': video_info.get('topic', '')
        }
        
        # Save to database (you might want to extend your database schema)
        # For now, we'll save to a separate uploads file
        uploads_file = "data/youtube_uploads.json"
        uploads = []
        
        if os.path.exists(uploads_file):
            with open(uploads_file, 'r', encoding='utf-8') as f:
                uploads = json.load(f)
        
        uploads.append(upload_data)
        
        with open(uploads_file, 'w', encoding='utf-8') as f:
            json.dump(uploads, f, indent=2, ensure_ascii=False)
    
    def get_upload_history(self) -> list:
        """Get history of uploaded videos"""
        uploads_file = "data/youtube_uploads.json"
        if os.path.exists(uploads_file):
            with open(uploads_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        return []
    
    def check_authentication_status(self) -> Dict[str, Any]:
        """Check if user is authenticated with YouTube"""
        try:
            # Check if credentials file exists
            if not os.path.exists(self.credentials_file):
                return {
                    'authenticated': False,
                    'message': f'Credentials file {self.credentials_file} not found'
                }
            
            # For now, we'll always require re-authentication for simplicity
            # In a production app, you'd want to implement proper token storage/refresh
            return {
                'authenticated': False,
                'message': 'Please authenticate to upload videos'
            }
            
        except Exception as e:
            return {
                'authenticated': False,
                'message': f'Authentication check failed: {str(e)}'
            }
    
    def revoke_credentials(self) -> bool:
        """Revoke stored credentials"""
        try:
            # Remove token file
            if os.path.exists(self.token_file):
                os.remove(self.token_file)
            
            return True
        except Exception as e:
            print(f"Failed to revoke credentials: {e}")
            return False
